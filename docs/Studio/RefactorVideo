ğŸ¯ Principio rector (muy importante)

Un chapter = un video completo, independiente y reproducible

El usuario percibe un solo video largo,
el sistema maneja una secuencia de videos cortos.

No hay concatenaciÃ³n.
No hay streaming raro.
No hay MSE.
No hay hacks.

â¸»

ğŸ§  Conceptos clave del nuevo sistema

Chapter
	â€¢	DuraciÃ³n: 5â€“10 s (definido por el LLM, no arbitrario)
	â€¢	Contiene:
	â€¢	ImÃ¡genes
	â€¢	Texto
	â€¢	Audio TTS
	â€¢	MÃºsica (opcional)
	â€¢	Se renderiza como video completo (MP4/WebM)

Video lÃ³gico (lo que ve el usuario)
	â€¢	Conjunto ordenado de chapters
	â€¢	Tiene:
	â€¢	duraciÃ³n total
	â€¢	progreso global
	â€¢	transcripciÃ³n completa

â¸»

ğŸ§± Tech stack (confirmado)
Capa
Tech
Frontend
Remix + React + TypeScript
Render
Canvas + Web Audio API + MediaRecorder
Player
HTML5 <video> (secuencial)
Storage
Supabase Storage
Metadata
Supabase Database
IA
LLM (chapters + script) + OpenAI TTS
IDE
VS Code
âŒ Netlify Functions
âŒ Server-side rendering de video
âŒ FFmpeg (por ahora)

â¸»

ğŸ§© FLUJO END-TO-END (alto nivel del refactor)
MantÃ©n lo que ya tenemos desde el user query hasta la generaciÃ³n de chapters es decir:
LLM â†’ Chapters (ya estÃ¡ Ok)
   â†“
Input Manager
   â†“
Chapter Renderer (1 video)
   â†“
Chapter Player (autoplay secuencial)
   â†“
Background Renderer (next chapter)
   â†“
Supabase
ğŸ”¹ 1ï¸âƒ£ LLM â€“ DefiniciÃ³n de chapters (cerebro del sistema, ya lo tenemos)
ğŸ”¹ 2ï¸âƒ£ Input Manager (por chapter)

Responsabilidad
	â€¢	Tomar la salida del LLM
	â€¢	Para cada chapter:
	â€¢	Asignar imÃ¡genes
	â€¢	Asociar audio TTS
	â€¢	Preparar timeline interno (0 â†’ duraciÃ³n chapter)

Salida
	â€¢	ChapterDescriptor[]
	â€¢	id
	â€¢	orden
	â€¢	duraciÃ³n
	â€¢	assets
	â€¢	audio
	â€¢	texto

â¸»

ğŸ”¹ 3ï¸âƒ£ Chapter Renderer (corazÃ³n del refactor)

âš ï¸ AquÃ­ estÃ¡ el reemplazo total de Netlify + chunks

Responsabilidad
	â€¢	Renderizar UN chapter â†’ UN video
	â€¢	Siempre client-side

Pipeline por chapter
	1.	Crear canvas (portrait, baja resoluciÃ³n)
	2.	Crear AudioContext
	3.	Dibujar imÃ¡genes + texto (timeline local)
	4.	Reproducir TTS (+ mÃºsica opcional)
	5.	MediaRecorder graba solo este chapter
	6.	Resultado: chapter_X.mp4

â±ï¸ Tiempo tÃ­pico:
	â€¢	Chapter de 6 s â†’ listo en ~6â€“7 s

â¸»

ğŸ”¹ 4ï¸âƒ£ Chapter Player (UX clave)

Este mÃ³dulo define si la experiencia se siente premium o amateur.

Responsabilidades
	â€¢	Reproducir chapters en secuencia
	â€¢	Autoplay inmediato del siguiente
	â€¢	Preload del siguiente chapter
	â€¢	Mostrar progreso global, no por chapter
	â€¢	Transiciones suaves (fade-in/out)

UX mental del usuario

â€œEstoy viendo un solo video que avanzaâ€

UX real
	â€¢	<video> cambia de source
	â€¢	pero el usuario no lo percibe

â¸»

ğŸ”¹ 5ï¸âƒ£ Render en background (magia de velocidad)

Este es el killer feature.

Flujo
	1.	Renderizas chapter 1
	2.	Empieza playback
	3.	Mientras el usuario ve chapter 1:
	â€¢	Renderizas chapter 2 en background
	4.	Termina chapter 1:
	â€¢	Chapter 2 ya estÃ¡ listo â†’ autoplay
	5.	Repetir

ğŸ”¥ Resultado:
	â€¢	Tiempo hasta ver algo: ~5 s
	â€¢	CPU distribuido
	â€¢	Mobile feliz

â¸»

ğŸ”¹ 6ï¸âƒ£ Supabase â€“ Persistencia por chapter

Storage
	â€¢	Cada chapter se guarda como archivo independiente
/videos/{videoId}/chapter_01.mp4
/videos/{videoId}/chapter_02.mp4
Database
	â€¢	Tabla videos
	â€¢	Tabla chapters

Cada chapter tiene:
	â€¢	order
	â€¢	duration
	â€¢	storage path
	â€¢	free / paid (ğŸ’°)

(Para el save per chapter, si no tenemos usuario logged in es decir estamos en usuario  guess , el video lo guarda la casa  - tipo usuario comodÃ­n llamado curios - si estÃ¡ logged in  obvio se almacena el id del usuario que lo creÃ³ ( asÃ­  para cada chapter)
ğŸ”¹ 7ï¸âƒ£ MonetizaciÃ³n (nativa, sin hacks a futuro pero creando ya el campo free/paid dejemos todo free por ahora paid se incorpora luego)

Tu arquitectura ya la permite ğŸ‘‡
	â€¢	Chapters 1â€“2 â†’ free
	â€¢	Chapter 3+ â†’ locked
	â€¢	Paywall antes de continuar
	â€¢	Ads entre chapters
	â€¢	â€œUnlock next chapterâ€

Esto NO serÃ­a posible con un solo video.

â¸»

ğŸ”¹ 8ï¸âƒ£ Export final (opcional por ahora no MVP)

Cuando el usuario quiere:

â€œDescargar el video completoâ€

Opciones futuras:
	â€¢	Render completo en un solo pass
	â€¢	O ensamblar chapters (FFmpeg, opcional)

âš ï¸ No necesario para MVP